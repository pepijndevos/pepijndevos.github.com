---
layout: post
title: The Origin of Language
categories:
 - history
 - language
 - dutch
 - clojure
---

Dutch is an interesting language. It seems we're at a crossroad of German, French and English influences.

During the Roman empire, the river Rijn was the border of the Germanic and Roman empire, of which German and Italian are direct descendants[^1].

Dutch is very close to German, but it was and is influenced by the 'world languages' of the time. (The world was a lot smaller at that time) And so it happened that during 1800-1900 or so, French was spoken by the elite, and we where part of the French empire at times.

![Map of French and Roman empire][2]

If you look at a Dutch dictionary today, you can divide the words in 3 categories, Words that are a lot like German, Archaic and chic words from France and modern words from English.

Dutch is a lot like Common Lisp or Scala[^3]. If we'd make a cheesy map of Europe with languages and paradigms overlaid, you'd see that natural languages are complected and *very* multi-paradigm.

Programming languages are much more designed, and mostly unambiguous, like Esperanto or Lojban. Computers don't like ambiguity. Some languages, like Scheme, are still designed for growth though.

<embed id="VideoPlayback" src="http://video.google.com/googleplayer.swf?docid=-8860158196198824415&hl=en&fs=true" style="width:400px;height:326px" allowFullScreen="true" allowScriptAccess="always" type="application/x-shockwave-flash"> </embed>

Near the end Guy Steele argues that programming languages need to be more like natural ones, and the other way around.

As we have seen earlier, natural languages grow, and grow a lot. But I know from experience that adding words to your language that are not native, feels forced at times, does not go well with grammar, and leads to extra complexity.

On the other hand, natural languages should be simpler. But I argue that this has nothing to do with syllables, but with choosing simple words with but one meaning, concerning one thing.

But do our programming languages have this property? [Rich Hickey argues this is often not the case, and explains the word 'simple' in more detail.][4][^5]

I can only wonder what future languages will look like. Since our applications will be limited by our understanding, programming will be an art of omission and simplicity.

Last video, I promise. 'Uncle Bob' Martin shows us what progress we have made in software development. Not much, compared to [Moore's law][6]. We're still programming Lisp, and doing assignment, branching and iteration.

<iframe width="560" height="315" src="http://www.youtube.com/embed/mslMLp5bQD0" frameborder="0" allowfullscreen="allowfullscreen"> </iframe>

What we did with structured programming, with object orientated programming and with functional programming, is taking stuff away. We converted conventions to rules.

Maybe future languages will have rules about simplicity?

[^1]: I'm not a historian, I never followed a single history lesson. Take with a spoon of salt.
[2]: /images/map-europe.png
[^3]: More salt please; At least we're back at programming.
[4]: http://www.infoq.com/presentations/Simple-Made-Easy
[^5]: I can't seem to embed an InfoQ video.
[6]: http://en.wikipedia.org/wiki/Moore's_law